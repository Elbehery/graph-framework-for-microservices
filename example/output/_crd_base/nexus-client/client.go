// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"fmt"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"

	baseClientset "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/client/clientset/versioned"
	"gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/common"
	"gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/helper"

	baseconfigtsmtanzuvmwarecomv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/apis/config.tsm.tanzu.vmware.com/v1"
	basegnstsmtanzuvmwarecomv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/apis/gns.tsm.tanzu.vmware.com/v1"
	basepolicytsmtanzuvmwarecomv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/apis/policy.tsm.tanzu.vmware.com/v1"
	baseroottsmtanzuvmwarecomv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/apis/root.tsm.tanzu.vmware.com/v1"
	baseservicegrouptsmtanzuvmwarecomv1 "gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/compiler.git/_generated/apis/servicegroup.tsm.tanzu.vmware.com/v1"
)

type Clientset struct {
	baseClient        *baseClientset.Clientset
	rootTsmV1         *RootTsmV1
	configTsmV1       *ConfigTsmV1
	gnsTsmV1          *GnsTsmV1
	servicegroupTsmV1 *ServicegroupTsmV1
	policyTsmV1       *PolicyTsmV1
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	client.rootTsmV1 = newRootTsmV1(client)
	client.configTsmV1 = newConfigTsmV1(client)
	client.gnsTsmV1 = newGnsTsmV1(client)
	client.servicegroupTsmV1 = newServicegroupTsmV1(client)
	client.policyTsmV1 = newPolicyTsmV1(client)

	return client, nil
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootTsmV1 {
	return c.rootTsmV1
}
func (c *Clientset) Config() *ConfigTsmV1 {
	return c.configTsmV1
}
func (c *Clientset) Gns() *GnsTsmV1 {
	return c.gnsTsmV1
}
func (c *Clientset) Servicegroup() *ServicegroupTsmV1 {
	return c.servicegroupTsmV1
}
func (c *Clientset) Policy() *PolicyTsmV1 {
	return c.policyTsmV1
}

type RootTsmV1 struct {
	client *Clientset
}

func newRootTsmV1(client *Clientset) *RootTsmV1 {
	return &RootTsmV1{
		client: client,
	}
}

type ConfigTsmV1 struct {
	client *Clientset
}

func newConfigTsmV1(client *Clientset) *ConfigTsmV1 {
	return &ConfigTsmV1{
		client: client,
	}
}

type GnsTsmV1 struct {
	client *Clientset
}

func newGnsTsmV1(client *Clientset) *GnsTsmV1 {
	return &GnsTsmV1{
		client: client,
	}
}

type ServicegroupTsmV1 struct {
	client *Clientset
}

func newServicegroupTsmV1(client *Clientset) *ServicegroupTsmV1 {
	return &ServicegroupTsmV1{
		client: client,
	}
}

type PolicyTsmV1 struct {
	client *Clientset
}

func newPolicyTsmV1(client *Clientset) *PolicyTsmV1 {
	return &PolicyTsmV1{
		client: client,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) GetRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConfigGvk != nil {
		err := group.client.
			Config().
			DeleteConfigByName(ctx, result.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		RootTsmV1().
		Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// DeleteRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootTsmV1) CreateRootByName(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConfigGvk = nil

	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// DeleteRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootTsmV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			RootTsmV1().
			Roots().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// List returns slice of all existing objects of given type. Selectors can be provided in opts parameter.
func (group *RootTsmV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*RootRoot, err error) {
	list, err := group.client.baseClient.RootTsmV1().
		Roots().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*RootRoot, len(list.Items))
	for k, v := range list.Items {
		result[k] = &RootRoot{
			client: group.client,
			Root:   &v,
		}
	}
	return
}

type RootRoot struct {
	client *Clientset
	*baseroottsmtanzuvmwarecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *RootRoot) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootRoot) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		RootTsmV1().
		Roots().
		Update(ctx, obj.Root, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Root = result
	return nil
}

func (c *Clientset) RootRoot(displayName string) *rootRootTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.root.tsm.tanzu.vmware.com"] = displayName
	return &rootRootTsmV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// GetRootRoot calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetRootRoot(ctx context.Context, displayName string) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, displayName)
	return c.Root().GetRootByName(ctx, hashedName)
}

// AddRootRoot calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootRoot(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (result *RootRoot, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateRootByName(ctx, objToCreate)
}

// DeleteRootRoot calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeleteRootRoot(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, displayName)
	return c.Root().DeleteRootByName(ctx, hashedName)
}

// GetConfig returns child or link of given type
func (obj *RootRoot) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	if obj.Spec.ConfigGvk != nil {
		return obj.client.Config().GetConfigByName(ctx, obj.Spec.ConfigGvk.Name)
	}
	return
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (obj *RootRoot) DeleteConfig(ctx context.Context, displayName string) (err error) {
	parentLabels := make(map[string]string)
	for k, v := range obj.GetLabels() {
		parentLabels[k] = v
	}
	parentLabels[obj.CRDName()] = obj.DisplayName()
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parentLabels, displayName)
	err = obj.client.Config().DeleteConfigByName(ctx, hashedName)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootRootTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootRootTsmV1Chainer) Config(name string) *configConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.tsm.tanzu.vmware.com"] = name
	return &configConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootRootTsmV1Chainer) GetConfig(ctx context.Context, displayName string) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootTsmV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootTsmV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.GNSGvk != nil {
		err := group.client.
			Gns().
			DeleteGnsByName(ctx, result.Spec.GNSGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DNSGvk != nil {
		err := group.client.
			Gns().
			DeleteDnsByName(ctx, result.Spec.DNSGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// DeleteConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GNSGvk = nil
	objToCreate.Spec.DNSGvk = nil

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/configGvk",
		Value: baseconfigtsmtanzuvmwarecomv1.Child{
			Group: "config.tsm.tanzu.vmware.com",
			Kind:  "Config",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// DeleteConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConfigTsmV1().
			Configs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueMyStr :=
		objToUpdate.Spec.MyStr
	patchOpMyStr := PatchOp{
		Op:    "replace",
		Path:  "/spec/myStr",
		Value: patchValueMyStr,
	}
	patch = append(patch, patchOpMyStr)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// List returns slice of all existing objects of given type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	list, err := group.client.baseClient.ConfigTsmV1().
		Configs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConfigConfig, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ConfigConfig{
			client: group.client,
			Config: &v,
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		ConfigTsmV1().
		Configs().
		Update(ctx, obj.Config, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Config = result
	return nil
}

// GetGNS returns child or link of given type
func (obj *ConfigConfig) GetGNS(ctx context.Context) (
	result *GnsGns, err error) {
	if obj.Spec.GNSGvk != nil {
		return obj.client.Gns().GetGnsByName(ctx, obj.Spec.GNSGvk.Name)
	}
	return
}

// GetDNS returns child or link of given type
func (obj *ConfigConfig) GetDNS(ctx context.Context) (
	result *GnsDns, err error) {
	if obj.Spec.DNSGvk != nil {
		return obj.client.Gns().GetDnsByName(ctx, obj.Spec.DNSGvk.Name)
	}
	return
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateGnsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (obj *ConfigConfig) DeleteGNS(ctx context.Context, displayName string) (err error) {
	parentLabels := make(map[string]string)
	for k, v := range obj.GetLabels() {
		parentLabels[k] = v
	}
	parentLabels[obj.CRDName()] = obj.DisplayName()
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parentLabels, displayName)
	err = obj.client.Gns().DeleteGnsByName(ctx, hashedName)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// AddDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddDNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (result *GnsDns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateDnsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (obj *ConfigConfig) DeleteDNS(ctx context.Context, displayName string) (err error) {
	parentLabels := make(map[string]string)
	for k, v := range obj.GetLabels() {
		parentLabels[k] = v
	}
	parentLabels[obj.CRDName()] = obj.DisplayName()
	hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", parentLabels, displayName)
	err = obj.client.Gns().DeleteDnsByName(ctx, hashedName)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigTsmV1Chainer) GNS(name string) *gnsGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnses.gns.tsm.tanzu.vmware.com"] = name
	return &gnsGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGNS calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetGNS(ctx context.Context, displayName string) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetGnsByName(ctx, hashedName)
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateGnsByName(ctx, objToCreate)
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteGNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteGnsByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) DNS(name string) *dnsGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnses.gns.tsm.tanzu.vmware.com"] = name
	return &dnsGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDNS calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetDNS(ctx context.Context, displayName string) (result *GnsDns, err error) {
	hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetDnsByName(ctx, hashedName)
}

// AddDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddDNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (result *GnsDns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateDnsByName(ctx, objToCreate)
}

// DeleteDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteDNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteDnsByName(ctx, hashedName)
}

// GetGnsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetGnsByName(ctx context.Context, hashedName string) (*GnsGns, error) {
	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// DeleteGnsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteGnsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.GnsServiceGroupsGvk {
		err := group.client.
			Servicegroup().DeleteSvcGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.GnsAccessControlPolicyGvk != nil {
		err := group.client.
			Policy().
			DeleteAccessControlPolicyByName(ctx, result.Spec.GnsAccessControlPolicyGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gNSGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// DeleteGnsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateGnsByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GnsServiceGroupsGvk = nil
	objToCreate.Spec.GnsAccessControlPolicyGvk = nil
	objToCreate.Spec.DnsGvk = nil

	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/gNSGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Gns",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// DeleteGnsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateGnsByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			Gnses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueDomain :=
		objToUpdate.Spec.Domain
	patchOpDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/domain",
		Value: patchValueDomain,
	}
	patch = append(patch, patchOpDomain)

	patchValueUseSharedGateway :=
		objToUpdate.Spec.UseSharedGateway
	patchOpUseSharedGateway := PatchOp{
		Op:    "replace",
		Path:  "/spec/useSharedGateway",
		Value: patchValueUseSharedGateway,
	}
	patch = append(patch, patchOpUseSharedGateway)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueWorkloadSpec :=
		objToUpdate.Spec.WorkloadSpec
	patchOpWorkloadSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/workloadSpec",
		Value: patchValueWorkloadSpec,
	}
	patch = append(patch, patchOpWorkloadSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// List returns slice of all existing objects of given type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListGnses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsGns, err error) {
	list, err := group.client.baseClient.GnsTsmV1().
		Gnses().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GnsGns, len(list.Items))
	for k, v := range list.Items {
		result[k] = &GnsGns{
			client: group.client,
			Gns:    &v,
		}
	}
	return
}

type GnsGns struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Gns
}

// Delete removes obj and all it's children from the database.
func (obj *GnsGns) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteGnsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Gns = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsGns) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		GnsTsmV1().
		Gnses().
		Update(ctx, obj.Gns, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Gns = result
	return nil
}

// GetAllGnsServiceGroups returns all links or children of given type
func (obj *GnsGns) GetAllGnsServiceGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.GnsServiceGroupsGvk))
	for _, v := range obj.Spec.GnsServiceGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsServiceGroups returns link or child which has given displayName
func (obj *GnsGns) GetGnsServiceGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.GnsServiceGroupsGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// GetGnsAccessControlPolicy returns child or link of given type
func (obj *GnsGns) GetGnsAccessControlPolicy(ctx context.Context) (
	result *PolicyAccessControlPolicy, err error) {
	if obj.Spec.GnsAccessControlPolicyGvk != nil {
		return obj.client.Policy().GetAccessControlPolicyByName(ctx, obj.Spec.GnsAccessControlPolicyGvk.Name)
	}
	return
}

// GetDns returns child or link of given type
func (obj *GnsGns) GetDns(ctx context.Context) (
	result *GnsDns, err error) {
	if obj.Spec.DnsGvk != nil {
		return obj.client.Gns().GetDnsByName(ctx, obj.Spec.DnsGvk.Name)
	}
	return
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (result *ServicegroupSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Servicegroup().CreateSvcGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (obj *GnsGns) DeleteGnsServiceGroups(ctx context.Context, displayName string) (err error) {
	parentLabels := make(map[string]string)
	for k, v := range obj.GetLabels() {
		parentLabels[k] = v
	}
	parentLabels[obj.CRDName()] = obj.DisplayName()
	hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", parentLabels, displayName)
	err = obj.client.Servicegroup().DeleteSvcGroupByName(ctx, hashedName)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *basepolicytsmtanzuvmwarecomv1.AccessControlPolicy) (result *PolicyAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policy().CreateAccessControlPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (obj *GnsGns) DeleteGnsAccessControlPolicy(ctx context.Context, displayName string) (err error) {
	parentLabels := make(map[string]string)
	for k, v := range obj.GetLabels() {
		parentLabels[k] = v
	}
	parentLabels[obj.CRDName()] = obj.DisplayName()
	hashedName := helper.GetHashedName("accesscontrolpolicies.policy.tsm.tanzu.vmware.com", parentLabels, displayName)
	err = obj.client.Policy().DeleteAccessControlPolicyByName(ctx, hashedName)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// LinkDns links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GnsGns) LinkDns(ctx context.Context,
	linkToAdd *GnsDns) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dnsGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Dns",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Gns = result
	return nil
}

// UnlinkDns unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GnsGns) UnlinkDns(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Gns = result
	return nil

}

type gnsGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsGnsTsmV1Chainer) GnsServiceGroups(name string) *svcgroupServicegroupTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["svcgroups.servicegroup.tsm.tanzu.vmware.com"] = name
	return &svcgroupServicegroupTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsServiceGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetGnsServiceGroups(ctx context.Context, displayName string) (result *ServicegroupSvcGroup, err error) {
	hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Servicegroup().GetSvcGroupByName(ctx, hashedName)
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (result *ServicegroupSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Servicegroup().CreateSvcGroupByName(ctx, objToCreate)
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteGnsServiceGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Servicegroup().DeleteSvcGroupByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) GnsAccessControlPolicy(name string) *accesscontrolpolicyPolicyTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["accesscontrolpolicies.policy.tsm.tanzu.vmware.com"] = name
	return &accesscontrolpolicyPolicyTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsAccessControlPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetGnsAccessControlPolicy(ctx context.Context, displayName string) (result *PolicyAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("accesscontrolpolicies.policy.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policy().GetAccessControlPolicyByName(ctx, hashedName)
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *basepolicytsmtanzuvmwarecomv1.AccessControlPolicy) (result *PolicyAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("accesscontrolpolicies.policy.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policy().CreateAccessControlPolicyByName(ctx, objToCreate)
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteGnsAccessControlPolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("accesscontrolpolicies.policy.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policy().DeleteAccessControlPolicyByName(ctx, hashedName)
}

// GetDnsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetDnsByName(ctx context.Context, hashedName string) (*GnsDns, error) {
	result, err := group.client.baseClient.
		GnsTsmV1().
		Dnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsDns{
		client: group.client,
		Dns:    result,
	}, nil
}

// DeleteDnsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteDnsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		Dnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GnsTsmV1().
		Dnses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dNSGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// DeleteDnsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateDnsByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (*GnsDns, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		Dnses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dNSGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Dns",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsDns{
		client: group.client,
		Dns:    result,
	}, nil
}

// DeleteDnsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateDnsByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Dns) (*GnsDns, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			Dnses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		Dnses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsDns{
		client: group.client,
		Dns:    result,
	}, nil
}

// List returns slice of all existing objects of given type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListDnses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsDns, err error) {
	list, err := group.client.baseClient.GnsTsmV1().
		Dnses().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GnsDns, len(list.Items))
	for k, v := range list.Items {
		result[k] = &GnsDns{
			client: group.client,
			Dns:    &v,
		}
	}
	return
}

type GnsDns struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Dns
}

// Delete removes obj and all it's children from the database.
func (obj *GnsDns) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteDnsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Dns = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsDns) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		GnsTsmV1().
		Dnses().
		Update(ctx, obj.Dns, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.Dns = result
	return nil
}

type dnsGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetSvcGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) GetSvcGroupByName(ctx context.Context, hashedName string) (*ServicegroupSvcGroup, error) {
	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ServicegroupSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// DeleteSvcGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) DeleteSvcGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsServiceGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// DeleteSvcGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ServicegroupTsmV1) CreateSvcGroupByName(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (*ServicegroupSvcGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsServiceGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ServicegroupSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// DeleteSvcGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ServicegroupTsmV1) UpdateSvcGroupByName(ctx context.Context,
	objToUpdate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (*ServicegroupSvcGroup, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ServicegroupSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// List returns slice of all existing objects of given type. Selectors can be provided in opts parameter.
func (group *ServicegroupTsmV1) ListSvcGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*ServicegroupSvcGroup, err error) {
	list, err := group.client.baseClient.ServicegroupTsmV1().
		SvcGroups().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ServicegroupSvcGroup, len(list.Items))
	for k, v := range list.Items {
		result[k] = &ServicegroupSvcGroup{
			client:   group.client,
			SvcGroup: &v,
		}
	}
	return
}

type ServicegroupSvcGroup struct {
	client *Clientset
	*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup
}

// Delete removes obj and all it's children from the database.
func (obj *ServicegroupSvcGroup) Delete(ctx context.Context) error {
	err := obj.client.Servicegroup().DeleteSvcGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SvcGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ServicegroupSvcGroup) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().
		Update(ctx, obj.SvcGroup, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.SvcGroup = result
	return nil
}

type svcgroupServicegroupTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetAccessControlPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicyTsmV1) GetAccessControlPolicyByName(ctx context.Context, hashedName string) (*PolicyAccessControlPolicy, error) {
	result, err := group.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicyAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// DeleteAccessControlPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicyTsmV1) DeleteAccessControlPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PolicyConfigsGvk {
		err := group.client.
			Policy().DeleteACPConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsAccessControlPolicyGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// DeleteAccessControlPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicyTsmV1) CreateAccessControlPolicyByName(ctx context.Context,
	objToCreate *basepolicytsmtanzuvmwarecomv1.AccessControlPolicy) (*PolicyAccessControlPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PolicyConfigsGvk = nil

	result, err := group.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/gnsAccessControlPolicyGvk",
		Value: basepolicytsmtanzuvmwarecomv1.Child{
			Group: "policy.tsm.tanzu.vmware.com",
			Kind:  "AccessControlPolicy",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicyAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// DeleteAccessControlPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicyTsmV1) UpdateAccessControlPolicyByName(ctx context.Context,
	objToUpdate *basepolicytsmtanzuvmwarecomv1.AccessControlPolicy) (*PolicyAccessControlPolicy, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			PolicyTsmV1().
			AccessControlPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &PolicyAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// List returns slice of all existing objects of given type. Selectors can be provided in opts parameter.
func (group *PolicyTsmV1) ListAccessControlPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicyAccessControlPolicy, err error) {
	list, err := group.client.baseClient.PolicyTsmV1().
		AccessControlPolicies().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*PolicyAccessControlPolicy, len(list.Items))
	for k, v := range list.Items {
		result[k] = &PolicyAccessControlPolicy{
			client:              group.client,
			AccessControlPolicy: &v,
		}
	}
	return
}

type PolicyAccessControlPolicy struct {
	client *Clientset
	*basepolicytsmtanzuvmwarecomv1.AccessControlPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *PolicyAccessControlPolicy) Delete(ctx context.Context) error {
	err := obj.client.Policy().DeleteAccessControlPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicyAccessControlPolicy) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().
		Update(ctx, obj.AccessControlPolicy, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = result
	return nil
}

// GetAllPolicyConfigs returns all links or children of given type
func (obj *PolicyAccessControlPolicy) GetAllPolicyConfigs(ctx context.Context) (
	result []*PolicyACPConfig, err error) {
	result = make([]*PolicyACPConfig, 0, len(obj.Spec.PolicyConfigsGvk))
	for _, v := range obj.Spec.PolicyConfigsGvk {
		l, err := obj.client.Policy().GetACPConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPolicyConfigs returns link or child which has given displayName
func (obj *PolicyAccessControlPolicy) GetPolicyConfigs(ctx context.Context,
	displayName string) (result *PolicyACPConfig, err error) {
	l, ok := obj.Spec.PolicyConfigsGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Policy().GetACPConfigByName(ctx, l.Name)
	return
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *PolicyAccessControlPolicy) AddPolicyConfigs(ctx context.Context,
	objToCreate *basepolicytsmtanzuvmwarecomv1.ACPConfig) (result *PolicyACPConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["accesscontrolpolicies.policy.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["accesscontrolpolicies.policy.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policy().CreateACPConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Policy().GetAccessControlPolicyByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	return
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (obj *PolicyAccessControlPolicy) DeletePolicyConfigs(ctx context.Context, displayName string) (err error) {
	parentLabels := make(map[string]string)
	for k, v := range obj.GetLabels() {
		parentLabels[k] = v
	}
	parentLabels[obj.CRDName()] = obj.DisplayName()
	hashedName := helper.GetHashedName("acpconfigs.policy.tsm.tanzu.vmware.com", parentLabels, displayName)
	err = obj.client.Policy().DeleteACPConfigByName(ctx, hashedName)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Policy().GetAccessControlPolicyByName(ctx, obj.GetName())
	if err == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	return
}

type accesscontrolpolicyPolicyTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *accesscontrolpolicyPolicyTsmV1Chainer) PolicyConfigs(name string) *acpconfigPolicyTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["acpconfigs.policy.tsm.tanzu.vmware.com"] = name
	return &acpconfigPolicyTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPolicyConfigs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *accesscontrolpolicyPolicyTsmV1Chainer) GetPolicyConfigs(ctx context.Context, displayName string) (result *PolicyACPConfig, err error) {
	hashedName := helper.GetHashedName("acpconfigs.policy.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policy().GetACPConfigByName(ctx, hashedName)
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *accesscontrolpolicyPolicyTsmV1Chainer) AddPolicyConfigs(ctx context.Context,
	objToCreate *basepolicytsmtanzuvmwarecomv1.ACPConfig) (result *PolicyACPConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("acpconfigs.policy.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policy().CreateACPConfigByName(ctx, objToCreate)
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *accesscontrolpolicyPolicyTsmV1Chainer) DeletePolicyConfigs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("acpconfigs.policy.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policy().DeleteACPConfigByName(ctx, hashedName)
}

// GetACPConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicyTsmV1) GetACPConfigByName(ctx context.Context, hashedName string) (*PolicyACPConfig, error) {
	result, err := group.client.baseClient.
		PolicyTsmV1().
		ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicyACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// DeleteACPConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicyTsmV1) DeleteACPConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		PolicyTsmV1().
		ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		PolicyTsmV1().
		ACPConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/policyConfigsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["accesscontrolpolicies.policy.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("accesscontrolpolicies.policy.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// DeleteACPConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicyTsmV1) CreateACPConfigByName(ctx context.Context,
	objToCreate *basepolicytsmtanzuvmwarecomv1.ACPConfig) (*PolicyACPConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DestSvcGroupsGvk = nil
	objToCreate.Spec.SourceSvcGroupsGvk = nil

	result, err := group.client.baseClient.
		PolicyTsmV1().
		ACPConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["accesscontrolpolicies.policy.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("accesscontrolpolicies.policy.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"policyConfigsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ACPConfig\", \"group\": \"policy.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		PolicyTsmV1().
		AccessControlPolicies().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicyACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// DeleteACPConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicyTsmV1) UpdateACPConfigByName(ctx context.Context,
	objToUpdate *basepolicytsmtanzuvmwarecomv1.ACPConfig) (*PolicyACPConfig, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			PolicyTsmV1().
			ACPConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueGns :=
		objToUpdate.Spec.Gns
	patchOpGns := PatchOp{
		Op:    "replace",
		Path:  "/spec/gns",
		Value: patchValueGns,
	}
	patch = append(patch, patchOpGns)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueTags :=
		objToUpdate.Spec.Tags
	patchOpTags := PatchOp{
		Op:    "replace",
		Path:  "/spec/tags",
		Value: patchValueTags,
	}
	patch = append(patch, patchOpTags)

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueConditions :=
		objToUpdate.Spec.Conditions
	patchOpConditions := PatchOp{
		Op:    "replace",
		Path:  "/spec/conditions",
		Value: patchValueConditions,
	}
	patch = append(patch, patchOpConditions)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		PolicyTsmV1().
		ACPConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &PolicyACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// List returns slice of all existing objects of given type. Selectors can be provided in opts parameter.
func (group *PolicyTsmV1) ListACPConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicyACPConfig, err error) {
	list, err := group.client.baseClient.PolicyTsmV1().
		ACPConfigs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*PolicyACPConfig, len(list.Items))
	for k, v := range list.Items {
		result[k] = &PolicyACPConfig{
			client:    group.client,
			ACPConfig: &v,
		}
	}
	return
}

type PolicyACPConfig struct {
	client *Clientset
	*basepolicytsmtanzuvmwarecomv1.ACPConfig
}

// Delete removes obj and all it's children from the database.
func (obj *PolicyACPConfig) Delete(ctx context.Context) error {
	err := obj.client.Policy().DeleteACPConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ACPConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicyACPConfig) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
		PolicyTsmV1().
		ACPConfigs().
		Update(ctx, obj.ACPConfig, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil
}

// GetAllDestSvcGroups returns all links or children of given type
func (obj *PolicyACPConfig) GetAllDestSvcGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.DestSvcGroupsGvk))
	for _, v := range obj.Spec.DestSvcGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDestSvcGroups returns link or child which has given displayName
func (obj *PolicyACPConfig) GetDestSvcGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.DestSvcGroupsGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// GetAllSourceSvcGroups returns all links or children of given type
func (obj *PolicyACPConfig) GetAllSourceSvcGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.SourceSvcGroupsGvk))
	for _, v := range obj.Spec.SourceSvcGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSourceSvcGroups returns link or child which has given displayName
func (obj *PolicyACPConfig) GetSourceSvcGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.SourceSvcGroupsGvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkDestSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *PolicyACPConfig) LinkDestSvcGroups(ctx context.Context,
	linkToAdd *ServicegroupSvcGroup) error {

	payload := "{\"spec\": {\"destSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.PolicyTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkDestSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *PolicyACPConfig) UnlinkDestSvcGroups(ctx context.Context,
	linkToRemove *ServicegroupSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/destSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.PolicyTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

// LinkSourceSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *PolicyACPConfig) LinkSourceSvcGroups(ctx context.Context,
	linkToAdd *ServicegroupSvcGroup) error {

	payload := "{\"spec\": {\"sourceSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.PolicyTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkSourceSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *PolicyACPConfig) UnlinkSourceSvcGroups(ctx context.Context,
	linkToRemove *ServicegroupSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sourceSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.PolicyTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

type acpconfigPolicyTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}
