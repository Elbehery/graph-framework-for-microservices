package nexus_client

import (
	"context"
	"encoding/json"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"

{{.HelperImport}}
baseClientset {{.BaseClientsetImport}}

{{.BaseImports}}
)

type Clientset struct {
	baseClient         *baseClientset.Clientset
	{{.ClientsetsApiGroups}}

}

func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	{{.InitApiGroups}}

	return client, nil
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

{{.ClientsetsApiGroupMethods}}

{{.ApiGroups}}

{{ range $key, $node := .Nodes }}
// Get hashes object's name and returns stored kubernetes object with all children and softlinks.
// To resolve a hashed name names of all consecutive parents must be provided in parents param in form of:
// {'object_crd_definition_name': 'object_name'}
func (obj *{{$node.GroupResourceType}}) Get(ctx context.Context, name string, parents map[string]string) (result *{{$node.GroupBaseImport}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", parents, name)
	return obj.GetByName(ctx, hashedName)
}

// GetByName works as Get but without hashing a name
func (obj *{{$node.GroupResourceType}}) GetByName(ctx context.Context, name string) (result *{{$node.GroupBaseImport}}, err error) {
	result, err = obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Get(ctx, name, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}
	return
}

// Delete hashes object's name and deletes the object and all it's children
// To resolve a hash names of all consecutive parents must be provided in parents param in form of:
// {'object_crd_definition_name': 'object_name'}
func (obj *{{$node.GroupResourceType}}) Delete(ctx context.Context, name string, parents map[string]string) (err error) {
	if parents == nil {
		parents = map[string]string{}
	}
	parents["nexus/is_name_hashed"] = "true"
	hashedName := helper.GetHashedName("{{$node.CrdName}}", parents, name)
	return obj.DeleteByName(ctx, hashedName, parents)
}

// DeleteByName works as Delete but without hashing a name
func (obj *{{$node.GroupResourceType}}) DeleteByName(ctx context.Context, name string, parents map[string]string) (err error) {
	{{if .HasChildren}}
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Get(ctx, name, metav1.GetOptions{})
	if err != nil {
		return err
	}
	if parents == nil {
		parents = make(map[string]string, 1)
	}

	if _, ok := result.GetLabels()["nexus/display_name"]; ok {
		parents["{{$node.CrdName}}"] = result.GetLabels()["nexus/display_name"]
	} else {
		parents["{{$node.CrdName}}"] = name
	}
	{{ end }}

	{{ range $key, $link := .Children }}
	{{ if $link.IsNamed }}
	for _, v := range result.Spec.{{$link.FieldName}}Gvk {
		err := obj.client.{{$link.GroupTypeName}}().{{$link.GroupResourceNameTitle}}().DeleteByName(ctx, v.Name, parents)
		if err != nil {
			return err
		}
	}
	{{ else }}
	if result.Spec.{{$link.FieldName}}Gvk != nil {
		err := obj.client.{{$link.GroupTypeName}}().{{$link.GroupResourceNameTitle}}().DeleteByName(ctx, result.Spec.{{$link.FieldName}}Gvk.Name, parents)
		if err != nil {
			return err
		}
	}
	{{ end }}
	{{ end }}

	err = obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Delete(ctx, name, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	{{if .Parent.HasParent}}
	var patch Patch
	{{if .Parent.IsNamed}}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$node.Parent.GvkFieldName}}/" + name,
	}
	{{ else }}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$node.Parent.GvkFieldName}}",
	}
	{{ end }}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parentName, ok := parents["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents["nexus/is_name_hashed"] == "true" {
		parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", parents, parentName)
	}
	_, err = obj.client.baseClient.{{$node.Parent.GroupTypeName}}().{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	{{ end }}

	return
}

// Create hashes object's name and creates an object in the apiserver. Only spec fields can be provided, links and
// children can't be added using this function.
// To hash object's name names of all consecutive parents must be provided in parents param in form of:
// {'object_crd_definition_name': 'object_name'}
func (obj *{{$node.GroupResourceType}}) Create(ctx context.Context, objToCreate *{{$node.GroupBaseImport}}, parents map[string]string) (result *{{$node.GroupBaseImport}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels["nexus/is_name_hashed"] != "true" {
		objToCreate.Labels["nexus/display_name"] = objToCreate.GetName()
		objToCreate.Labels["nexus/is_name_hashed"] = "true"
		hashedName := helper.GetHashedName("{{$node.CrdName}}", parents, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return obj.CreateByName(ctx, objToCreate, parents)
}

// CreateByName works as Create but without hashing the name
func (obj *{{$node.GroupResourceType}}) CreateByName(ctx context.Context, objToCreate *{{$node.GroupBaseImport}}, parents map[string]string) (result *{{$node.GroupBaseImport}}, err error) {
	for k, v := range parents {
		objToCreate.Labels[k] = v
	}
	if _, ok := objToCreate.Labels["nexus/display_name"]; !ok {
		objToCreate.Labels["nexus/display_name"] = objToCreate.GetName()
	}

	{{ range $key, $link := .LinksAndChildren }}objToCreate.Spec.{{$link.FieldName}}Gvk = nil
	{{ end }}
	result, err = obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	{{if .Parent.HasParent}}
	parentName, ok := parents["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels["nexus/is_name_hashed"] == "true" {
		parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", parents, parentName)
	}
	{{if .Parent.IsNamed}}
	payload := "{\"spec\": {\"{{$node.Parent.GvkFieldName}}\": {\"" + objToCreate.Name + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"{{$node.Kind}}\", \"group\": \"{{$node.Group}}\"}}}}"
	_, err = obj.client.baseClient.{{$node.Parent.GroupTypeName}}().{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ else }}
	var patch Patch
	patchOp := PatchOp{
		Op:    "replace",
		Path:  "/spec/{{$node.Parent.GvkFieldName}}",
		Value: {{$node.BaseImportName}}.Child{
		Group: "{{$node.Group}}",
		Kind:  "{{$node.Kind}}",
		Name:  objToCreate.Name,
	},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = obj.client.baseClient.{{$node.Parent.GroupTypeName}}().{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ end }}
	{{ end }}

	return
}

// Update hashes object's name and updates an object in the apiserver. Only spec fields and metadata can be updated,
// links and children can't be added or updated using this function.
// To hash the name names of all consecutive parents must be provided in parents param in form of:
// {'object_crd_definition_name': 'object_name'}
func (obj *{{$node.GroupResourceType}}) Update(ctx context.Context, objToUpdate *{{$node.GroupBaseImport}}, parents map[string]string) (result *{{$node.GroupBaseImport}}, err error) {
	if objToUpdate.Labels == nil {
		objToUpdate.Labels = map[string]string{}
	}
	if objToUpdate.Labels["nexus/is_name_hashed"] != "true" {
		objToUpdate.Labels["nexus/display_name"] = objToUpdate.GetName()
		objToUpdate.Labels["nexus/is_name_hashed"] = "true"
		hashedName := helper.GetHashedName("{{$node.CrdName}}", parents, objToUpdate.GetName())
		objToUpdate.Name = hashedName
	}
	return obj.UpdateByName(ctx, objToUpdate)
}

// UpdateByName works as Update but without hashing the name
func (obj *{{$node.GroupResourceType}}) UpdateByName(ctx context.Context, objToUpdate *{{$node.GroupBaseImport}}) (result *{{$node.GroupBaseImport}}, err error) {
	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)
	{{ range $key, $field := .Fields }}
	patchValue{{$field.FieldName}} := objToUpdate.Spec.{{$field.FieldName}}
		patchOp{{$field.FieldName}} := PatchOp{
		Op:    "replace",
		Path:  "/spec/{{$field.FieldNameTag}}",
		Value: patchValue{{$field.FieldName}},
	}
	patch = append(patch, patchOp{{$field.FieldName}})
	{{ end }}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return
}

{{ range $key, $link := .Links }}
// Add{{$link.FieldName}} updates srcObj with linkToAdd object
func (obj *{{$node.GroupResourceType}}) Add{{$link.FieldName}}(ctx context.Context, srcObj *{{$node.GroupBaseImport}}, linkToAdd *{{$link.GroupBaseImport}}) (result *{{$node.GroupBaseImport}}, err error) {
	{{ if $link.IsNamed }}
	payload := "{\"spec\": {\"{{$link.FieldNameGvk}}\": {\"" + linkToAdd.Name + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"{{$link.Kind}}\", \"group\": \"{{$link.Group}}\"}}}}"
	result, err = obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, srcObj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ else }}
	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/{{$link.FieldNameGvk}}",
		Value: {{$node.BaseImportName}}.Child{
		Group: "{{$link.Group}}",
		Kind:  "{{$link.Kind}}",
		Name:  linkToAdd.Name,
	},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, srcObj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ end }}

	return
}

// Remove{{$link.FieldName}} removes linkToRemove object from srcObj
func (obj *{{$node.GroupResourceType}}) Remove{{$link.FieldName}}(ctx context.Context, srcObj *{{$node.GroupBaseImport}}, linkToRemove *{{$link.GroupBaseImport}}) (result *{{$node.GroupBaseImport}}, err error) {
	var patch Patch
	{{if $link.IsNamed}}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}/" + linkToRemove.Name,
	}
	{{ else }}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}",
	}
	{{ end }}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, srcObj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return
}
{{ end }}

{{ range $key, $link := .LinksAndChildren }}
func (obj *{{$node.GroupResourceType}}) Get{{$link.FieldName}}(ctx context.Context, srcObj *{{$node.GroupBaseImport}}{{ if $link.IsNamed }}, {{$link.FieldName}}ObjectName string{{end}}) (result *{{$link.GroupBaseImport}}, err error) {
	{{ if $link.IsNamed }}parents := srcObj.GetLabels()
	if parents == nil {
		parents = make(map[string]string, 1)
	}
	if _, ok := srcObj.GetLabels()["nexus/display_name"]; ok {
		parents["{{$node.CrdName}}"] = srcObj.GetLabels()["nexus/display_name"]
	} else {
		parents["{{$node.CrdName}}"] = srcObj.GetName()
	}
	hashedName := helper.GetHashedName(result.CRDName(), parents, {{$link.FieldName}}ObjectName)
	return obj.Get{{$link.FieldName}}ByName(ctx, srcObj, hashedName)
	{{ else }}return obj.Get{{$link.FieldName}}ByName(ctx, srcObj){{ end }}
}

func (obj *{{$node.GroupResourceType}}) Get{{$link.FieldName}}ByName(ctx context.Context, srcObj *{{$node.GroupBaseImport}}{{ if $link.IsNamed }}, {{$link.FieldName}}ObjectName string{{end}}) (result *{{$link.GroupBaseImport}}, err error) {
	{{ if $link.IsNamed }}if srcObj.Spec.{{$link.FieldName}}Gvk != nil {
		l, ok := srcObj.Spec.{{$link.FieldName}}Gvk[{{$link.FieldName}}ObjectName]
		if ok {
			return obj.client.baseClient.{{$link.GroupTypeName}}().{{$link.GroupResourceNameTitle}}().Get(ctx, l.Name, metav1.GetOptions{})
		}
	}
	var parentName string
	if srcObj.Labels != nil && srcObj.Labels["nexus/display_name"] != "" {
		parentName = srcObj.Labels["nexus/display_name"]
	} else {
		parentName = srcObj.GetName()
	}
	return nil, fmt.Errorf("there's no child %s for parent %s", {{$link.FieldName}}ObjectName, parentName)
	{{ else }}if srcObj.Spec.{{$link.FieldName}}Gvk != nil {
		return obj.client.baseClient.{{$link.GroupTypeName}}().{{$link.GroupResourceNameTitle}}().Get(ctx, srcObj.Spec.{{$link.FieldName}}Gvk.Name, metav1.GetOptions{})
	} else {
		var parentName string
		if srcObj.Labels != nil && srcObj.Labels["nexus/display_name"] != "" {
			parentName = srcObj.Labels["nexus/display_name"]
		} else {
			parentName = srcObj.GetName()
		}
		return nil, fmt.Errorf("There's no child {{$link.FieldName}} for parent %s", parentName)
	}
	{{ end }}
}

{{ if $link.IsNamed }}
func (obj *{{$node.GroupResourceType}}) GetAll{{$link.FieldName}}(ctx context.Context, srcObj *{{$node.GroupBaseImport}}) (result []*{{$link.GroupBaseImport}}, err error) {
	result = make([]*{{$link.GroupBaseImport}}, 0, len(srcObj.Spec.{{$link.FieldName}}Gvk))
	for _, v := range srcObj.Spec.{{$link.FieldName}}Gvk {
		l, err := obj.client.baseClient.{{$link.GroupTypeName}}().{{$link.GroupResourceNameTitle}}().Get(ctx, v.Name, metav1.GetOptions{})
		if err != nil {
			var parentName string
			if srcObj.Labels != nil && srcObj.Labels["nexus/display_name"] != "" {
				parentName = srcObj.Labels["nexus/display_name"]
			} else {
				parentName = srcObj.GetName()
			}
			return nil, fmt.Errorf("couldn't get child %s for parent %s: %v", v.Name, parentName, err)
		}
		result = append(result, l)
	}
	return
}
{{ end }}
{{ end }}
{{end}}